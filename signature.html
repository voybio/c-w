<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Loom Engine // Tensile Protocol</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tailwind Config for specific colors/animations -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <style>
        body { background-color: #050505; color: #d6d3d1; overflow: hidden; }
        /* Smooth rendering for SVG */
        path { vector-effect: non-scaling-stroke; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- ICONS (Inline SVGs to remove external dependencies) ---
        
        const IconCommand = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M15 6v12a3 3 0 1 0 3-3H6a3 3 0 1 0 3 3V6a3 3 0 1 0-3 3h12a3 3 0 1 0-3-3" />
            </svg>
        );

        const IconX = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M18 6 6 18" />
                <path d="m6 6 12 12" />
            </svg>
        );

        const IconDownload = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                <polyline points="7 10 12 15 17 10" />
                <line x1="12" x2="12" y1="15" y2="3" />
            </svg>
        );

        const IconSparkles = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z" />
            </svg>
        );

        // --- UTILS ---

        const degToRad = (deg) => (deg * Math.PI) / 180;

        // Deterministic Hashing for Colors
        const getColor = (char, i) => {
            const code = char.charCodeAt(0);
            const palettes = [
                ['#10b981', '#059669', '#34d399'], // Emerald (Tech)
                ['#3b82f6', '#2563eb', '#60a5fa'], // Blue (Flux)
                ['#8b5cf6', '#7c3aed', '#a78bfa'], // Violet (Void)
                ['#ec4899', '#db2777', '#f472b6'], // Pink (Neon)
                ['#f59e0b', '#d97706', '#fbbf24'], // Amber (Energy)
            ];
            
            // Pick palette based on first char of string (or something stable)
            const pIndex = code % palettes.length;
            // Pick shade based on position
            return palettes[pIndex][i % 3];
        };

        // --- GENERATOR LOGIC ---

        const generateWeave = (input) => {
            if (!input) return [];
            
            const strands = [];
            const chars = input.split('');
            const total = chars.length;
            
            // Base circle division
            const step = 360 / (total > 0 ? total : 1);

            chars.forEach((char, i) => {
                const code = char.charCodeAt(0);
                
                // Determine connections based on char relationships
                // We create multiple strands per character for density
                
                const density = 3 + (code % 5); // 3 to 7 strands per letter
                
                for (let j = 0; j < density; j++) {
                    const startAngle = (i * step) + (j * 2); // Slight offset
                    
                    // Target is determined by the char code (pseudo-random but deterministic)
                    // Connect to a point roughly 'code' degrees away
                    const targetOffset = (code * 7) % 360; 
                    const endAngle = startAngle + 120 + targetOffset;

                    // Control points determine the "tension" of the curve
                    // Tighter curves = closer to center
                    const tension = 0.3 + ((code % 10) / 20); // 0.3 to 0.8
                    
                    strands.push({
                        startAngle,
                        endAngle,
                        cp1Angle: startAngle + (targetOffset / 2),
                        cp2Angle: endAngle - (targetOffset / 2),
                        color: getColor(char, j),
                        opacity: 0.1 + (j * 0.05), // Layering opacity
                        width: j === 0 ? 1.5 : 0.5 // Primary strand is thicker
                    });
                }
            });

            return strands;
        };

        // --- RENDERER ---

        const WeaveRenderer = ({ seed, svgRef }) => {
            const strands = useMemo(() => generateWeave(seed), [seed]);
            const radius = 200;

            // Helper to get coordinates on the circle
            const getPoint = (angle, r) => {
                const rad = degToRad(angle);
                return {
                    x: Math.cos(rad) * r,
                    y: Math.sin(rad) * r
                };
            };

            return (
                <svg 
                    ref={svgRef}
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="-250 -250 500 500" 
                    className="w-full h-full transition-all duration-1000 ease-out"
                    style={{ filter: 'drop-shadow(0 0 30px rgba(255,255,255,0.05))' }}
                >
                    <defs>
                        <radialGradient id="core-glow" cx="50%" cy="50%" r="50%">
                            <stop offset="0%" stopColor="#fff" stopOpacity="0.1" />
                            <stop offset="100%" stopColor="#000" stopOpacity="0" />
                        </radialGradient>
                    </defs>

                    {/* The Void/Background (Transparent for export, strictly visual) */}
                    <circle r="250" fill="transparent" />

                    {/* Central Core Glow */}
                    <circle r="100" fill="url(#core-glow)" />

                    {/* Outer Rim */}
                    <circle r={radius} fill="none" stroke="#333" strokeWidth="1" opacity="0.5" strokeDasharray="4 4" />
                    <circle r={radius + 15} fill="none" stroke="#222" strokeWidth="20" opacity="1" />

                    {/* The Weave */}
                    <g>
                        {strands.map((strand, k) => {
                            const start = getPoint(strand.startAngle, radius);
                            const end = getPoint(strand.endAngle, radius);
                            
                            // Control points are pulled towards the center based on "tension"
                            // We simulate this by using a smaller radius for CPs
                            const cpRadius = radius * 0.4; // Pull tight
                            const cp1 = getPoint(strand.cp1Angle, cpRadius);
                            const cp2 = getPoint(strand.cp2Angle, cpRadius);

                            return (
                                <path 
                                    key={k}
                                    d={`M ${start.x} ${start.y} C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${end.x} ${end.y}`}
                                    fill="none"
                                    stroke={strand.color}
                                    strokeWidth={strand.width}
                                    strokeOpacity={strand.opacity}
                                    strokeLinecap="round"
                                    className="mix-blend-screen" // Additive blending look
                                />
                            );
                        })}
                    </g>

                    {/* Data Points (Decorations on the rim) */}
                    {strands.filter((_, i) => i % 5 === 0).map((strand, k) => {
                        const p = getPoint(strand.startAngle, radius + 25);
                        return (
                            <circle key={`dot-${k}`} cx={p.x} cy={p.y} r={1.5} fill="#fff" opacity="0.5" />
                        );
                    })}

                </svg>
            );
        };

        // --- APP COMPONENT ---

        const App = () => {
            const [input, setInput] = useState('SEQUENCE');
            const [downloading, setDownloading] = useState(false);
            const svgRef = useRef(null);

            const hashKey = useMemo(() => {
                let hash = 0;
                for (let i = 0; i < input.length; i++) hash = ((hash << 5) - hash) + input.charCodeAt(i);
                return Math.abs(hash).toString(16).toUpperCase().padStart(8, '0');
            }, [input]);

            const handleDownload = () => {
                if (!svgRef.current) return;
                setDownloading(true);
                
                const serializer = new XMLSerializer();
                let source = serializer.serializeToString(svgRef.current);
                if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
                    source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
                }
                
                const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
                const link = document.createElement("a");
                link.href = url;
                link.download = `LOOM_${input}.svg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                setTimeout(() => setDownloading(false), 1000);
            };

            return (
                <div className="w-full h-screen bg-[#050505] flex flex-col items-center justify-center font-sans text-stone-300 overflow-hidden relative selection:bg-white/20">
                
                {/* 1. Canvas Area */}
                <div className="relative flex-grow w-full flex items-center justify-center pb-20">
                    
                    {/* Subtle Vignette */}
                    <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,transparent_0%,#050505_100%)] pointer-events-none z-10" />
                    
                    {/* The Weave */}
                    <div className="w-[85vmin] h-[85vmin] animate-pulse-slow">
                        <WeaveRenderer seed={input} svgRef={svgRef} />
                    </div>

                </div>

                {/* 2. The "Loom" Interface (Single Line) */}
                <div className="absolute bottom-10 left-0 w-full z-50 flex flex-col items-center">
                    
                    {/* The Minimal Input Strip */}
                    <div className="relative w-full max-w-xl group">
                        
                        {/* Input Line */}
                        <div className="flex items-center border-b border-white/20 group-focus-within:border-white/60 transition-colors pb-2 px-4">
                            <div className="mr-4 text-emerald-500 animate-pulse">
                                <IconCommand size={18} />
                            </div>
                            
                            <input 
                                type="text" 
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                placeholder="INITIATE WEAVE..."
                                className="flex-grow bg-transparent text-2xl font-light tracking-[0.15em] text-white placeholder-white/10 focus:outline-none uppercase font-mono"
                                spellCheck={false}
                                autoFocus
                            />

                            <div className="ml-4 flex items-center space-x-4">
                                {/* Clear Button */}
                                {input && (
                                    <button 
                                        onClick={() => setInput('')}
                                        className="text-stone-600 hover:text-white transition-colors"
                                    >
                                        <IconX size={18} />
                                    </button>
                                )}
                                
                                {/* Download Button */}
                                <button 
                                    onClick={handleDownload}
                                    className={`transition-colors ${downloading ? 'text-emerald-500' : 'text-stone-500 hover:text-emerald-400'}`}
                                    title="Extract SVG"
                                >
                                    <IconDownload size={18} />
                                </button>
                            </div>
                        </div>

                        {/* Meta Data Line */}
                        <div className="flex justify-between mt-2 px-4 text-[9px] font-mono uppercase tracking-widest text-stone-600">
                            <div className="flex items-center space-x-2">
                                <IconSparkles size={10} />
                                <span>Tensile Protocol Active</span>
                            </div>
                            <div className="opacity-0 group-hover:opacity-100 transition-opacity">
                                Hash: {hashKey}
                            </div>
                        </div>

                    </div>

                </div>

                </div>
            );
        };

        // --- RENDER ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>